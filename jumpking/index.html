<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JumpKingClone</title>
  <style>
    /* General styles */
    body {
      margin: 0;
      padding: 0;
      background-color: black;
      touch-action: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }

    #canvas {
      display: block;
      margin: 0 auto;
    }

    /* Virtual controls (mobile only) */
    .controls {
      position: fixed;
      bottom: 10%;
      width: 100%;
      display: flex;
      justify-content: center;
      gap: 20px;
      visibility: hidden; /* Hidden by default */
    }

    .control-btn {
      width: 60px;
      height: 60px;
      background-color: #555;
      border-radius: 50%;
      color: white;
      font-size: 20px;
      font-weight: bold;
      display: flex;
      justify-content: center;
      align-items: center;
      touch-action: manipulation;
      user-select: none;
    }

    .control-btn:active {
      background-color: #333;
    }

    @media (max-width: 768px) {
      .controls {
        visibility: visible; /* Show on small screens */
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="800" height="600"></canvas>

  <!-- Virtual controls for mobile -->
  <div class="controls">
    <div class="control-btn" id="left">←</div>
    <div class="control-btn" id="up">↑</div>
    <div class="control-btn" id="right">→</div>
    <div class="control-btn" id="jump">␣</div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");

    // Simulate key events
    function triggerKeyEvent(keyCode, type) {
      const event = new KeyboardEvent(type, {
        keyCode,
        code: keyCode === 32 ? "Space" : `Arrow${String.fromCharCode(keyCode)}`,
        bubbles: true,
      });
      document.dispatchEvent(event);
    }

    // Event listeners for touch controls
    document.getElementById("left").addEventListener("touchstart", () => triggerKeyEvent(37, "keydown"));
    document.getElementById("left").addEventListener("touchend", () => triggerKeyEvent(37, "keyup"));

    document.getElementById("up").addEventListener("touchstart", () => triggerKeyEvent(38, "keydown"));
    document.getElementById("up").addEventListener("touchend", () => triggerKeyEvent(38, "keyup"));

    document.getElementById("right").addEventListener("touchstart", () => triggerKeyEvent(39, "keydown"));
    document.getElementById("right").addEventListener("touchend", () => triggerKeyEvent(39, "keyup"));

    document.getElementById("jump").addEventListener("touchstart", () => triggerKeyEvent(32, "keydown"));
    document.getElementById("jump").addEventListener("touchend", () => triggerKeyEvent(32, "keyup"));

    // Your existing engine setup code
    const GODOT_CONFIG = {
      "args": [],
      "canvasResizePolicy": 2,
      "executable": "index",
      "experimentalVK": false,
      "fileSizes": { "index.pck": 8085408, "index.wasm": 19761972 },
      "focusCanvas": true,
      "gdnativeLibs": []
    };

    var engine = new Engine(GODOT_CONFIG);

    (function() {
      const INDETERMINATE_STATUS_STEP_MS = 100;
      var statusProgress = document.getElementById('status-progress');
      var statusProgressInner = document.getElementById('status-progress-inner');
      var statusIndeterminate = document.getElementById('status-indeterminate');
      var statusNotice = document.getElementById('status-notice');

      var initializing = true;
      var statusMode = 'hidden';

      var animationCallbacks = [];
      function animate(time) {
        animationCallbacks.forEach(callback => callback(time));
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);

      function setStatusMode(mode) {
        if (statusMode === mode || !initializing)
          return;
        [statusProgress, statusIndeterminate, statusNotice].forEach(elem => {
          elem.style.display = 'none';
        });
        animationCallbacks = animationCallbacks.filter(function(value) {
          return (value != animateStatusIndeterminate);
        });
        switch (mode) {
          case 'progress':
            statusProgress.style.display = 'block';
            break;
          case 'indeterminate':
            statusIndeterminate.style.display = 'block';
            animationCallbacks.push(animateStatusIndeterminate);
            break;
          case 'notice':
            statusNotice.style.display = 'block';
            break;
          case 'hidden':
            break;
          default:
            throw new Error('Invalid status mode');
        }
        statusMode = mode;
      }

      function animateStatusIndeterminate(ms) {
        var i = Math.floor(ms / INDETERMINATE_STATUS_STEP_MS % 8);
        if (statusIndeterminate.children[i].style.borderTopColor == '') {
          Array.prototype.slice.call(statusIndeterminate.children).forEach(child => {
            child.style.borderTopColor = '';
          });
          statusIndeterminate.children[i].style.borderTopColor = '#dfdfdf';
        }
      }

      function setStatusNotice(text) {
        while (statusNotice.lastChild) {
          statusNotice.removeChild(statusNotice.lastChild);
        }
        var lines = text.split('\n');
        lines.forEach((line) => {
          statusNotice.appendChild(document.createTextNode(line));
          statusNotice.appendChild(document.createElement('br'));
        });
      };

      function displayFailureNotice(err) {
        var msg = err.message || err;
        console.error(msg);
        setStatusNotice(msg);
        setStatusMode('notice');
        initializing = false;
      };

      if (!Engine.isWebGLAvailable()) {
        displayFailureNotice('WebGL not available');
      } else {
        setStatusMode('indeterminate');
        engine.startGame({
          'onProgress': function(current, total) {
            if (total > 0) {
              statusProgressInner.style.width = current / total * 100 + '%';
              setStatusMode('progress');
              if (current === total) {
                // wait for progress bar animation
                setTimeout(() => {
                  setStatusMode('indeterminate');
                }, 500);
              }
            } else {
              setStatusMode('indeterminate');
            }
          },
        }).then(() => {
          setStatusMode('hidden');
          initializing = false;
        }, displayFailureNotice);
      }
    })();
  </script>
</body>
</html>
